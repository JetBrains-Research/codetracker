package org.jetbrains.research.ml.codetracker.reporting

import com.intellij.openapi.diagnostic.SubmittedReportInfo
import com.intellij.openapi.diagnostic.SubmittedReportInfo.SubmissionStatus
import org.eclipse.egit.github.core.Issue
import org.eclipse.egit.github.core.Label
import org.eclipse.egit.github.core.RepositoryId
import org.eclipse.egit.github.core.client.GitHubClient
import org.eclipse.egit.github.core.service.IssueService
import java.util.*

/**
 * Provides functionality to create and send GitHub issues when an exception is thrown by a plugin.
 */
object ErrorReport {
    private const val TOKEN_FILE = "errorReporterToken"
    private const val GIT_REPO_USER = "JetBrains-Research"
    private const val GIT_REPO = "codetracker"
    private const val ISSUE_LABEL_BUG = "bug"
    private const val ISSUE_LABEL_AUTO_GENERATED = "auto-generated"
    private const val GIT_ISSUE_TITLE = "[auto-generated] %s"
    private const val HTML_URL_TO_CREATE_NEW_ISSUE = "https://github.com/JetBrains-Research/codetracker/issues/new"

    fun sendFeedback(errorInformation: ErrorInformation): SubmittedReportInfo? {
        return try {
            val client = GitHubClient()
            client.setOAuth2Token(GitHubAccessTokenScrambler.decrypt(ErrorReport::class.java.getResourceAsStream(
                TOKEN_FILE
            )))
            val repoID = RepositoryId(GIT_REPO_USER, GIT_REPO)
            val issueService = IssueService(client)
            var newGibHubIssue: Issue = createNewGibHubIssue(errorInformation)
            val duplicate: Issue? = findFirstDuplicate(
                newGibHubIssue.title,
                issueService,
                repoID
            )
            val isNewIssue = duplicate?.let {
                val newErrorComment: String = generateGitHubIssueBody(errorInformation)
                issueService.createComment(repoID, it.number, newErrorComment)
                newGibHubIssue = it
                false
            } ?: {
                newGibHubIssue = issueService.createIssue(repoID, newGibHubIssue)
                true
            }()
            SubmittedReportInfo(
                newGibHubIssue.htmlUrl,
                "Send bug report",
                if (isNewIssue) SubmissionStatus.NEW_ISSUE else SubmissionStatus.DUPLICATE
            )
        } catch (e: Exception) {
            SubmittedReportInfo(
                HTML_URL_TO_CREATE_NEW_ISSUE,
                "Don't send bug report",
                SubmissionStatus.FAILED
            )
        }
    }

    private fun createNewGibHubIssue(errorInformation: ErrorInformation): Issue {
        val gitHubIssue = Issue()
        gitHubIssue.title = String.format(
            GIT_ISSUE_TITLE,
            errorInformation.getErrorInformation(ErrorInformationType.ERROR_MESSAGE)
        )
        gitHubIssue.body = generateGitHubIssueBody(errorInformation)
        val bugLabel = Label()
        bugLabel.name = ISSUE_LABEL_BUG
        val autoGeneratedLabel = Label()
        autoGeneratedLabel.name = ISSUE_LABEL_AUTO_GENERATED
        gitHubIssue.labels = listOf(autoGeneratedLabel, bugLabel)
        return gitHubIssue
    }

    private fun generateGitHubIssueBody(errorInformation: ErrorInformation): String {
        val result = StringBuilder()
        enumValues<UserInformationType>().forEach {
            result.append("- ").append(it.readableValue).append(": ").append(errorInformation.getUserInformation(it)).append("\n")
        }
        result.append("\n```\n")
        result.append(errorInformation.getErrorInformation(ErrorInformationType.ERROR_STACKTRACE))
        result.append("\n```\n")
        return result.toString()
    }

    private fun findFirstDuplicate(
        uniqueTitle: String,
        service: IssueService,
        repo: RepositoryId
    ): Issue? {
        val searchParameters: HashMap<String, String> = hashMapOf(IssueService.FILTER_STATE to IssueService.STATE_OPEN)
        service.pageIssues(repo, searchParameters).forEach {
            it.forEach { issue ->
                if (issue.title == uniqueTitle) {
                    return issue
                }
            }
        }
        return null
    }
}